---
title: 图-cnblog
date: 2023-02-17 09:02:35
permalink: /pages/0495c3/
categories:
  - 算法
  - js数据结构与算法
tags:
  - 
author: 
  name: lingxin
  link: https://github.com/linxin1123
---
## 图

- 一个二元关系



### 图的表示法

- 邻接矩阵
  - ![](https://img2023.cnblogs.com/blog/3089561/202302/3089561-20230205100506275-919527854.png)
- 邻接表
  - ![](https://img2023.cnblogs.com/blog/3089561/202302/3089561-20230205100505840-811289047.png)



### 图的遍历

- 深度优先搜索
  1. 访问根节点（开始节点）
  2. 循环访问没有访问过的邻接节点（递归，新节点跳回第一步）
- 广度优先搜索
  1. 维护一个队列
  2. 节点入队（第一次开始节点）
  3. 节点出队并访问，把当前节点没有访问过的邻接节点入队（循环第三步，直到队列为空）



### LeetCode 题目

#### [65. 有效数字](https://leetcode.cn/problems/valid-number/)

**有效数字**（按顺序）可以分成以下几个部分：

1. 一个 **小数** 或者 **整数**
2. （可选）一个 `'e'` 或 `'E'` ，后面跟着一个 **整数**

**小数**（按顺序）可以分成以下几个部分：

1. （可选）一个符号字符（`'+'` 或 `'-'`）
2. 下述格式之一：
   1. 至少一位数字，后面跟着一个点 `'.'`
   2. 至少一位数字，后面跟着一个点 `'.'` ，后面再跟着至少一位数字
   3. 一个点 `'.'` ，后面跟着至少一位数字

**整数**（按顺序）可以分成以下几个部分：

1. （可选）一个符号字符（`'+'` 或 `'-'`）
2. 至少一位数字

部分有效数字列举如下：`["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]`

部分无效数字列举如下：`["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]`

给你一个字符串 `s` ，如果 `s` 是一个 **有效数字** ，请返回 `true` 。

 

**示例 1：**

```
输入：s = "0"
输出：true
```

**示例 2：**

```
输入：s = "e"
输出：false
```

**示例 3：**

```
输入：s = "."
输出：false
```

 

**提示：**

- `1 <= s.length <= 20`
- `s` 仅含英文字母（大写和小写），数字（`0-9`），加号 `'+'` ，减号 `'-'` ，或者点 `'.'` 。



##### 解题思路

- 使用刚刚学习的图

- 有效状态自动机

  ```js
  	// blank 表示空格
      // sign 表示正负号
      // digit 表示数字
      // dot 就是小数点
      // e 就是 e
  
      // 初态0
  
      const graph={
          // 每次可以的走法，即加上一个新的字符会怎样
              
          // 空格        
          0:{'blank':0,'digit':1,'dot':2,'sign':3},
          // [0-9] 满足
          1:{'digit':1,'dot':4,'e':5,'E':5},
          // .
          2:{'digit':4},
          // [+-]
          3:{'digit':1,'dot':2,},
          // [0-9]. .[0-9] 满足
          4:{'digit':4,'e':5,'E':5},
          // .[0-9][e/E] [0-9].[e/E]
          5:{'sign':6,'digit':7},
          
          // .[0-9][e/E][+-] [0-9].[e/E][+-]
          6:{'digit':7},
  
          // 满足
          7:{'digit':7}
          
  }
  ```

- 符合题意的状态

  ```shell
  1,4,7
  ```



- 完整代码

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isNumber = function (s) {
  // blank 表示空格
  // sign 表示正负号
  // digit 表示数字
  // dot 就是小数点
  // e 就是 e

  // 初态0

  const graph = {
    // 每次可以的走法，即加上一个新的字符会怎样

    // 空格
    0: { blank: 0, digit: 1, dot: 2, sign: 3 },
    // [0-9] 满足
    1: { digit: 1, dot: 4, e: 5, E: 5 },
    // .
    2: { digit: 4 },
    // [+-]
    3: { digit: 1, dot: 2 },
    // [0-9]. .[0-9] 满足
    4: { digit: 4, e: 5, E: 5 },
    // .[0-9][e/E] [0-9].[e/E]
    5: { sign: 6, digit: 7 },

    // .[0-9][e/E][+-] [0-9].[e/E][+-]
    6: { digit: 7 },

    // 满足
    7: { digit: 7 }
  }

  // 遍历字符串

  let state = 0

  for (let i = 0; i < s.length; i++) {
    // console.log(s[i])

    // console.log(parseInt(s[i])-48)

    // if(s[i]-48>=0 && s[i]-48<=9){
    //     console.log(s[i])
    // }

    // console.log(s[i].charCodeAt())

    let code = s[i].charCodeAt()

    if (code - 48 >= 0 && code - 48 <= 9) {
      state = graph[state]['digit']
    } else if (s[i] === 'e' || s[i] === 'E') {
      state = graph[state]['e']
    } else if (s[i] === '.') {
      state = graph[state]['dot']
    } else if (s[i] === '+' || s[i] === '-') {
      state = graph[state]['sign']
    } else {
      return false
    }

    console.log(state)

    if (!state) {
      return false
    }
  }

  if (state === 1 || state === 4 || state === 7) {
    return true
  }

  return false
}

```



#### [417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

难度中等536收藏分享切换为英文接收动态反馈

有一个 `m × n` 的矩形岛屿，与 **太平洋** 和 **大西洋** 相邻。 **“太平洋”** 处于大陆的左边界和上边界，而 **“大西洋”** 处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个 `m x n` 的整数矩阵 `heights` ， `heights[r][c]` 表示坐标 `(r, c)` 上单元格 **高于海平面的高度** 。

岛上雨水较多，如果相邻单元格的高度 **小于或等于** 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回网格坐标 `result` 的 **2D 列表** ，其中 `result[i] = [ri, ci]` 表示雨水从单元格 `(ri, ci)` 流动 **既可流向太平洋也可流向大西洋** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)

```
输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

**示例 2：**

```
输入: heights = [[2,1],[1,2]]
输出: [[0,0],[0,1],[1,0],[1,1]]
```

 

**提示：**

- `m == heights.length`
- `n == heights[r].length`
- `1 <= m, n <= 200`
- `0 <= heights[r][c] <= 105`





##### 解题思路

```
1. 考虑使用深度优先搜索
2. 遍历矩阵四周可以逆流而上的所有格子
3. 同时向大西洋和太平洋逆流而上的所有格子
```